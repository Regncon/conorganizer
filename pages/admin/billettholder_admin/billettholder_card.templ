package billettholderadmin

import (
	"fmt"
	"html"
	"strconv"
	"strings"
	"unicode"
	"database/sql"
	"log/slog"
	"net/http"
	"encoding/json"

	"github.com/gorilla/sessions"
	"github.com/go-chi/chi/v5"
	"github.com/Regncon/conorganizer/models"
	datastar "github.com/starfederation/datastar-go/datastar"
)

func highlightSearchTerm(text, searchTerm string) string {
	if len(searchTerm) == 0 {
		return html.EscapeString(text)
	}

	// Build a quick-lookup set of runes in searchTerm (lower-cased).
	set := make(map[rune]struct{}, len(searchTerm))
	for _, r := range searchTerm {
		set[unicode.ToLower(r)] = struct{}{}
	}

	var out strings.Builder
	for _, r := range text {
		escaped := html.EscapeString(string(r)) // protect any HTML in the input
		if _, ok := set[unicode.ToLower(r)]; ok {
			out.WriteString("<b style=\"color: var(--color-primary-strong);\">")
			out.WriteString(escaped)
			out.WriteString("</b>")
		} else {
			out.WriteString(escaped)
		}
	}

	return out.String()
}

func addEmailToBilettholderRoute(
	router chi.Router,
	db *sql.DB,
	logger *slog.Logger,
	store sessions.Store,
	notifyUpdate func(string),
) {

	router.Post("/new-email/{id}/", func(w http.ResponseWriter, r *http.Request) {
		logger.Info("Received request to add new email to billettholder")
		billettholderID := chi.URLParam(r, "id")
		if billettholderID == "" {
			logger.Error("Billettholder ID is missing in the URL")
			http.Error(w, "Billettholder ID is required", http.StatusBadRequest)
			return
		}
		logger.Info("Billettholder ID", slog.String("id", billettholderID))
		signals := map[string]string{}
		if err := datastar.ReadSignals(r, &signals); err != nil { /* ... */
		}

		newEmailAddress := ""
		for k, v := range signals {
			fmt.Println("Signal key:", k, "value:", v)
			if strings.HasPrefix(k, "newEmail-") {
				idStr := strings.TrimPrefix(k, "newEmail-")
				id, err := strconv.Atoi(idStr)
				if err != nil {
					logger.Error("Invalid billettholder ID in signal key", slog.String("key", k), slog.Any("error", err))
					http.Error(w, "Invalid billettholder ID", http.StatusBadRequest)
					return
				}
				if strconv.Itoa(id) == billettholderID {
					newEmailAddress = v
					break
				}
			}
		}
		logger.Info("new email added", slog.String("email", newEmailAddress))

		if newEmailAddress == "" {
			logger.Error("New email address is missing in the request")
			http.Error(w, "New email address is required", http.StatusBadRequest)
			return
		}

		var exists int
		queryCheck := `SELECT COUNT(*) FROM billettholder_emails WHERE billettholder_id = ? AND email = ?`
		err := db.QueryRow(queryCheck, billettholderID, newEmailAddress).Scan(&exists)
		if err != nil {
			logger.Error("Failed to check existing emails in the database", slog.Any("error", err))
			http.Error(w, "Failed to check existing emails in the database", http.StatusInternalServerError)
			return
		}
		if exists > 0 {
			logger.Error("Email address already exists for this billettholder", slog.String("email", newEmailAddress))
			http.Error(w, "Email address already exists for this billettholder", http.StatusConflict)
			return
		}

		query := `INSERT INTO billettholder_emails (billettholder_id, email, kind) VALUES (?, ?, 'Manual')`
		_, err = db.Exec(query, billettholderID, newEmailAddress)
		if err != nil {
			logger.Error("Failed to insert new email into the database", slog.Any("error", err))
			http.Error(w, "Failed to add new email to the database", http.StatusInternalServerError)
			return
		}

		payload := map[string]any{
			fmt.Sprintf("newEmail-%s", billettholderID): "",
		}

		b, err := json.Marshal(payload)
		if err != nil {
			logger.Error("Failed to marshal patch signals payload", slog.Any("error", err))
			http.Error(w, "Failed to encode patch signals", http.StatusInternalServerError)
			return
		}

		sse := datastar.NewSSE(w, r)
		if err := sse.PatchSignals(b); err != nil {
			logger.Error("Failed to patch signals", slog.Any("error", err))
			http.Error(w, "Failed to patch signals", http.StatusInternalServerError)
			return
		}

		sessionID, _ := upsertSessionID(store, r, w)
		if notifyUpdate != nil {
			notifyUpdate(sessionID)
		}
	})
}

templ billettholderCard(billettholder models.Billettholder, searchTerm string) {
	<div class="card" style="display:flex; flex-direction:column; gap:0.5rem; padding: 1rem; border-radius: 8px; background: rgb(49, 53, 78); color: #ffffff;">
		<p style="margin:0;">
			<strong>Bestilling: </strong> @templ.Raw(highlightSearchTerm(strconv.Itoa(billettholder.OrderID), searchTerm))
		</p>
		<p style="margin:0;">
			<strong>Type: </strong> @templ.Raw(highlightSearchTerm(billettholder.TicketType, searchTerm))
		</p>
		<p style="margin:0;">
			<strong>Navn:</strong>
			<em>
				@templ.Raw(highlightSearchTerm(billettholder.FirstName+""+billettholder.LastName, searchTerm))
			</em>
		</p>
		for _, email := range billettholder.Emails {
			if email.Kind == "Ticket" {
				<div style="display: flex; align-items: center; gap:0.5rem; ">
					<strong>Epost:</strong>
					<a href={ "mailto:" + email.Email }>
						@templ.Raw(highlightSearchTerm(email.Email, searchTerm))
					</a>
				</div>
			}
		}
		<div style="display: flex; align-items: center; gap:0.5rem; ">
			if billettholder.IsOver18 {
				<img
					src="/static/icons/adults-only.svg"
					alt="adults only"
				/>
				<p><strong>Alder:</strong> Over 18</p>
			} else {
				<img
					width="34px"
					height="34px"
					src="/static/icons/child-friendly.svg"
					alt="child friendly"
				/>
				<p><strong>Alder:</strong> Under 18</p>
			}
		</div>
		<span>Andre epostadresser p√• samme bestilling:</span>
		for _, email := range billettholder.Emails {
			if email.Kind == "Associated" || email.Kind == "Manual" {
				<a href={ "mailto:" + email.Email }>
					@templ.Raw(highlightSearchTerm(email.Email, searchTerm))
				</a>
			}
		}
		<input
			data-bind={ "newEmail-" + strconv.Itoa(billettholder.ID) }
		/>
		<button
			class="btn btn--outline"
			data-on-click={ datastar.PostSSE("/admin/billettholder/api/new-email/%d/", billettholder.ID) }
		>
			Legg til epost
		</button>
	</div>
}
