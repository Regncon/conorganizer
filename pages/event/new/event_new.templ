package eventForm

import (
	"database/sql"
	"fmt"
	"github.com/go-chi/chi/v5"
	datastar "github.com/starfederation/datastar/sdk/go"
	"log/slog"
	"net/http"
	"time"
)

type EventFormStruct struct {
	Title             string    `json:"title"`
	Description       string    `json:"description"`
	ImageURL          *string   `json:"image_url,omitempty"`
	System            *string   `json:"system,omitempty"`
	HostName          string    `json:"host_name"`
	Host              *string   `json:"host,omitempty"`
	RoomName          *string   `json:"room_name,omitempty"`
	PuljeName         *string   `json:"pulje_name,omitempty"`
	MaxPlayers        int       `json:"max_players"`
	ChildFriendly     bool      `json:"child_friendly"`
	AdultsOnly        bool      `json:"adults_only"`
	BeginnerFriendly  bool      `json:"beginner_friendly"`
	ExperiencedOnly   bool      `json:"experienced_only"`
	CanBeRunInEnglish bool      `json:"can_be_run_in_english"`
	LongRunning       bool      `json:"long_running"`
	ShortRunning      bool      `json:"short_running"`
	InsertedTime      time.Time `json:"inserted_time"`
}

type ValidationResultStruct struct {
	IsTitleValid             bool
	IsDescriptionValid       bool
	IsImageURLValid          bool
	IsSystemValid            bool
	IsHostNameValid          bool
	IsHostValid              bool
	IsRoomNameValid          bool
	IsPuljeNameValid         bool
	IsMaxPlayersValid        bool
	IsChildFriendlyValid     bool
	IsAdultsOnlyValid        bool
	IsBeginnerFriendlyValid  bool
	IsExperiencedOnlyValid   bool
	IsCanBeRunInEnglishValid bool
	IsLongRunningValid       bool
	IsShortRunningValid      bool
	IsValid                  bool
}

func SetupExampleInlineValidation(db *sql.DB, eventFormRouter chi.Router, logger *slog.Logger) error {
	eventFormRouter.Route("/inline_validation/data", func(dataRouter chi.Router) {
		checkEventFromValidity := func(eventForm *EventFormStruct) ValidationResultStruct {

			isTitleValid := len(eventForm.Title) > 0
			isDescriptionValid := len(eventForm.Description) > 0
			isMaxPlayersValid := eventForm.MaxPlayers > 0
			isSystemValid := len(*eventForm.System) > 0
			isHostNameValid := len(eventForm.HostName) > 0
			isHostValid := len(*eventForm.Host) > 0
			isRoomNameValid := len(*eventForm.RoomName) > 0
			isPuljeNameValid := len(*eventForm.PuljeName) > 0
			isChildFriendlyValid := eventForm.ChildFriendly
			isAdultsOnlyValid := eventForm.AdultsOnly
			isBeginnerFriendlyValid := eventForm.BeginnerFriendly
			isExperiencedOnlyValid := eventForm.ExperiencedOnly
			isCanBeRunInEnglishValid := eventForm.CanBeRunInEnglish
			isLongRunningValid := eventForm.LongRunning
			isShortRunningValid := eventForm.ShortRunning

			isValid :=
				isTitleValid &&
					isDescriptionValid &&
					isMaxPlayersValid &&
					isSystemValid &&
					isHostNameValid &&
					isHostValid &&
					isRoomNameValid &&
					isPuljeNameValid &&
					isChildFriendlyValid &&
					isAdultsOnlyValid &&
					isBeginnerFriendlyValid &&
					isExperiencedOnlyValid &&
					isCanBeRunInEnglishValid &&
					isLongRunningValid &&
					isShortRunningValid

			return ValidationResultStruct{
				IsTitleValid:             isTitleValid,
				IsDescriptionValid:       isDescriptionValid,
				IsMaxPlayersValid:        isMaxPlayersValid,
				IsSystemValid:            isSystemValid,
				IsHostNameValid:          isHostNameValid,
				IsHostValid:              isHostValid,
				IsRoomNameValid:          isRoomNameValid,
				IsPuljeNameValid:         isPuljeNameValid,
				IsChildFriendlyValid:     isChildFriendlyValid,
				IsAdultsOnlyValid:        isAdultsOnlyValid,
				IsBeginnerFriendlyValid:  isBeginnerFriendlyValid,
				IsExperiencedOnlyValid:   isExperiencedOnlyValid,
				IsCanBeRunInEnglishValid: isCanBeRunInEnglishValid,
				IsLongRunningValid:       isLongRunningValid,
				IsShortRunningValid:      isShortRunningValid,
				IsValid:                  isValid,
			}
		}

		dataRouter.Get("/", func(w http.ResponseWriter, r *http.Request) {
			eventForm := &EventFormStruct{}
			if err := datastar.ReadSignals(r, eventForm); err != nil {
				http.Error(w, err.Error(), http.StatusBadRequest)
				return
			}
			sse := datastar.NewSSE(w, r)
			eventFormValidationResult := checkEventFromValidity(eventForm)
			sse.MergeFragmentTempl(EventFromValidation(eventForm, eventFormValidationResult))
		})

		dataRouter.Put("/", func(w http.ResponseWriter, r *http.Request) {
			eventForm := &EventFormStruct{}
			if err := datastar.ReadSignals(r, eventForm); err != nil {
				http.Error(w, err.Error(), http.StatusBadRequest)
				return
			}

			eventFormValidationResult := checkEventFromValidity(eventForm)
			sse := datastar.NewSSE(w, r)
			var node templ.Component

			if !eventFormValidationResult.IsValid {
				node = EventFromValidation(eventForm, eventFormValidationResult)
			}

			if eventFormValidationResult.IsValid {
				_, err := saveNewFormEvent(db, logger, eventForm, w)
				if err != nil {
					node = inlineValidationFailedSaving(err)
				}
				node = inlineValidationThankYou()
			}

			fmt.Printf("Validation Result: %+v\n", eventFormValidationResult)
			fmt.Printf("Submitted Event Form: %+v\n", eventForm)

			sse.MergeFragmentTempl(node)
		})
	})

	return nil
}

templ inlineValidationFieldComponent(label, field string, isValid bool, isNotValidErrorLabelFmt string, labelArgs ...any) {
	<div class="form-control">
		<label class="label">
			<span class="label-text">{ label }</span>
		</label>
		<input
			class={ "input input-bordered", templ.KV("input-error",!isValid) }
			data-bind={ field }
			data-on-keydown__debounce.500ms={ datastar.GetSSE("/event/api/new/inline_validation/data") }
			data-testid={ "input_" + field }
		/>
		if !isValid {
			<label class="text-sm font-bold text-error" data-testid={ "validation_" + field }>{ fmt.Sprintf( isNotValidErrorLabelFmt, labelArgs...) }</label>
		}
	</div>
}

templ inlineValidationUserComponent(eventForm *EventFormStruct, isEmailValid, isFirstNameValid, isLastNameValid, isValid bool) {
	<div
		id="inline_validation"
		class="flex flex-col gap-4"
		data-signals__ifmissing={ templ.JSONString(eventForm) }
	>
		<div class="text-2xl font-bold">Sign Up</div>
		<div>
			// @inlineValidationFieldComponent("Email Address", "email", isEmailValid, "Email '%s' is already taken or is invalid.  Please enter another email.", eventForm.Email)
			// @inlineValidationFieldComponent("First Name", "firstName", isFirstNameValid, "First name must be at least 2 characters.")
			// @inlineValidationFieldComponent("Last Name", "lastName", isLastNameValid, "Last name must be at least 2 characters.")
		</div>
		<button
			class="btn btn-success"
			disabled?={ !isValid }
			data-on-click={ datastar.PutSSE("/event/api/new/inline_validation/data") }
			data-testid="submit_button"
		>
			Add User
		</button>
		<div class="divider"></div>
	</div>
}

templ inlineValidationThankYou() {
	<div id="inline_validation" class="alert alert-success">
		Thank you for signing up!
	</div>
}

templ inlineValidationFailedSaving(err error) {
	<div id="inline_validation" class="alert alert-error">
		Failed to save event. Please try again. Error: { fmt.Sprintf("%v", err) }
	</div>
}

templ EventFromValidation(data *EventFormStruct, vr ValidationResultStruct) {
	<form
		class="flex flex-col gap-4"
		data-signals__ifmissing={ templ.JSONString(data) }
	>
		<div class="form-control">
			<label class="label">
				<span class="label-text">Tittel på spillmodul / arrangement</span>
			</label>
			<input
				class="input input-bordered"
				type="text"
				data-bind="title"
				data-testid="title_input"
			/>
		</div>
		<div class="form-control">
			<label class="label">
				<span class="label-text">Kort oppsummering</span>
			</label>
			<input
				class="input input-bordered"
				type="text"
				data-bind="summary"
				data-testid="summary_input"
			/>
		</div>
		<div class="form-control">
			<label class="label">
				<span class="label-text">E-postadresse</span>
			</label>
			<input
				class="input input-bordered"
				type="email"
				data-bind="email"
				data-testid="email_input"
			/>
		</div>
		<div class="form-control">
			<label class="label">
				<span class="label-text">Arrangørens navn</span>
			</label>
			<input
				class="input input-bordered"
				type="text"
				data-bind="organizerName"
				data-testid="organizerName_input"
			/>
		</div>
		<div class="form-control">
			<label class="label">
				<span class="label-text">Na telefonnummer kan vi nå deg på?</span>
			</label>
			<input
				class="input input-bordered"
				type="text"
				data-bind="phoneNumber"
				data-testid="phoneNumber_input"
			/>
		</div>
		<div class="form-control">
			<label class="label">
				<span class="label-text">Spillsystem</span>
			</label>
			<input
				class="input input-bordered"
				type="text"
				data-bind="system"
				data-testid="system_input"
			/>
		</div>
		<div class="form-control">
			<label class="label">
				<span class="label-text">Skildring av modulen (Inkl test i programmet)</span>
			</label>
			<textarea
				class="textarea textarea-bordered"
				data-bind="description"
				data-testid="description_input"
			></textarea>
		</div>
		<div class="form-control">
			<label class="label">
				<span class="label-text">Kva type spel er det?</span>
			</label>
			<div class="flex flex-col gap-2 pl-4">
				<label class="cursor-pointer flex items-center gap-2">
					<input
						type="radio"
						name="gameType"
						class="radio"
						value="Rollespel"
						data-bind="gameType"
					/>
					<span>Rollespel</span>
				</label>
				<label class="cursor-pointer flex items-center gap-2">
					<input
						type="radio"
						name="gameType"
						class="radio"
						value="Brettspel"
						data-bind="gameType"
					/>
					<span>Brettspel</span>
				</label>
				<label class="cursor-pointer flex items-center gap-2">
					<input
						type="radio"
						name="gameType"
						class="radio"
						value="LARP"
						data-bind="gameType"
					/>
					<span>LARP</span>
				</label>
				<label class="cursor-pointer flex items-center gap-2">
					<input
						type="radio"
						name="gameType"
						class="radio"
						value="Annet"
						data-bind="gameType"
					/>
					<span>Annet</span>
				</label>
			</div>
		</div>
		<div class="form-control">
			<label class="label">
				<span class="label-text">Maks antall spillere</span>
			</label>
			<input
				class="input input-bordered"
				type="number"
				min="0"
				data-bind="maxPlayers"
				data-testid="maxPlayers_input"
			/>
		</div>
		<div class="form-control">
			<label class="label">
				<span class="label-text">Kan for øvrig kan du arrangere?</span>
			</label>
			<div class="flex flex-col gap-2 pl-4">
				<label class="cursor-pointer flex items-center gap-2">
					<input
						type="checkbox"
						class="checkbox"
						data-bind="fridayEvening"
					/>
					<span>Fredag Kveld</span>
				</label>
				<label class="cursor-pointer flex items-center gap-2">
					<input
						type="checkbox"
						class="checkbox"
						data-bind="saturdayMorning"
					/>
					<span>Lørdag Morgen</span>
				</label>
				<label class="cursor-pointer flex items-center gap-2">
					<input
						type="checkbox"
						class="checkbox"
						data-bind="saturdayEvening"
					/>
					<span>Lørdag Kveld</span>
				</label>
				<label class="cursor-pointer flex items-center gap-2">
					<input
						type="checkbox"
						class="checkbox"
						data-bind="sundayMorning"
					/>
					<span>Søndag Morgen</span>
				</label>
			</div>
		</div>
		<div>
			<button
				class="btn btn-primary"
				type="submit"
				data-on-click={ datastar.PutSSE("/event/api/new/inline_validation/data") }
			>
				Send inn arrangement
			</button>
		</div>
	</form>
}

// Dette er en ny templ-komponent som viser skjemaet med alle feltene.
// Merk at du kan legge til data-on-* attributter, inline validering, etc. etter behov.
templ EventForm() {
	<div>
		<h1>Melde på nytt arrangement</h1>
		@EventFromValidation(&EventFormStruct{}, ValidationResultStruct{})
	</div>
}

func saveNewFormEvent(db *sql.DB, logger *slog.Logger, eventForm *EventFormStruct, w http.ResponseWriter) (int64, error) {
	query := `
		INSERT INTO events (
			title,
			description,
			image_url,
			system,
			host_name,
			host,
			room_name,
			pulje_name,
			max_players,
			child_friendly,
			adults_only,
			beginner_friendly,
			experienced_only,
			can_be_run_in_english,
			long_running,
			short_running,
			inserted_time
		) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`

	if eventForm.InsertedTime.IsZero() {
		eventForm.InsertedTime = time.Now()
	}

	result, insertError := db.Exec(query,
		eventForm.Title,
		eventForm.Description,
		eventForm.ImageURL,
		eventForm.System,
		eventForm.HostName,
		eventForm.Host,
		eventForm.RoomName,
		eventForm.PuljeName,
		eventForm.MaxPlayers,
		eventForm.ChildFriendly,
		eventForm.AdultsOnly,
		eventForm.BeginnerFriendly,
		eventForm.ExperiencedOnly,
		eventForm.CanBeRunInEnglish,
		eventForm.LongRunning,
		eventForm.ShortRunning,
		eventForm.InsertedTime,
	)

	if insertError != nil {
		logger.Error("Error updating event", "insertError", insertError)
		http.Error(w, fmt.Sprintf("Error updating event: %v", insertError), http.StatusBadRequest)
		return 0, insertError
	}

	rowsAffected, rowsAffectedErr := result.RowsAffected()
	if rowsAffectedErr != nil {
		logger.Error("Error getting rows affected", "rowsAffectedErr", rowsAffectedErr)
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		return 0, rowsAffectedErr
	}

	if rowsAffected == 0 {
		logger.Error("Event not found or no changes made")
		http.Error(w, "Event not found or no changes made", http.StatusNotFound)
		return 0, nil
	}
	fmt.Printf("Event saved successfully: %v\n", eventForm)
	return result.LastInsertId()
}
