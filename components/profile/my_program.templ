package profilecomponent

import (
	"database/sql"
	"fmt"
	"log/slog"
	"sort"
	"time"

	"github.com/Regncon/conorganizer/components/event_components"
	billettholderService "github.com/Regncon/conorganizer/service/billettholder"
	"github.com/Regncon/conorganizer/service/eventimage"
	"github.com/Regncon/conorganizer/service/requestctx"
)

type UserEvent struct {
	// UserEvent represents an event that a user is either playing in or is a gamemaster for
	EventID     string
	Title       string
	Intro       string
	Description string
	ImageURL    string
	Host        string
	EventType   string
	PuljeID     string
	PuljeName   string
	StartTime   time.Time
	EndTime     time.Time
	IsGM        bool
}

templ MyPropgram(userInfo requestctx.UserRequestInfo, db *sql.DB, logger *slog.Logger, eventImageDir *string) {
	// Fetch all events the user is participating in or running
	{{ events, err := GetAllEventsForUser(userInfo, db, logger) }}
	// Fetch all events the user has marked as interested in
	{{ interests, interestErr := getAllInterestsForUser(userInfo, db, logger) }}
	{{  // Define the 4 festival time slots (puljer)
		puljer := []struct {
			displayName string
			puljeID     string
			time        string
			event       UserEvent
			interests   []UserInterest
		}{
			{displayName: "Fredag kveld", puljeID: "FredagKveld", time: "(18:00 - 23:00)"},
			{displayName: "Lørdag morgen", puljeID: "LordagMorgen", time: "(10:00 - 15:00)"},
			{displayName: "Lørdag kveld", puljeID: "LordagKveld", time: "(18:00 - 23:00)"},
			{displayName: "Søndag morgen", puljeID: "SondagMorgen", time: "(10:00 - 15:00)"},
		}
	}}
	{{  // Assign events and interests to their corresponding time slots
		for i := range puljer {
			// Find the event assigned to this time slot (if any)
			for _, event := range events {
				if event.PuljeName == puljer[i].displayName {
					puljer[i].event = event
					break
				}
			}
			// Collect all interests that match this time slot
			for _, interest := range interests {
				if interest.PuljeID == puljer[i].puljeID {
					puljer[i].interests = append(puljer[i].interests, interest)
				}
			}
		}
	}}
	{{  // Sort interests by interest level within each time slot
		// Priority: Veldig interessert (1) > Middels interessert (2) > Litt interessert (3)
		interestOrder := map[string]int{
			"Veldig interessert":  1,
			"Middels interessert": 2,
			"Litt interessert":    3,
		}
		for i := range puljer {
			sort.Slice(puljer[i].interests, func(a, b int) bool {
				orderA := interestOrder[puljer[i].interests[a].InterestLevel]
				orderB := interestOrder[puljer[i].interests[b].InterestLevel]
				if orderA == 0 {
					orderA = 999 // Unknown interest levels go to the end
				}
				if orderB == 0 {
					orderB = 999
				}
				return orderA < orderB
			})
		}
	}}
	<style>
		.program-pulje-list {
			display: flex;
			flex-direction: column;
			gap: var(--responsive-pane-padding);
		}
		.program-pulje-container {
			display: flex;
			flex-direction: column;
			gap: var(--spacing-2x);
		}
		h3.program-pulje {
			font-size: var(--text-heading-3);
			font-weight: bold;
			color: var(--color-text-strong);
		}
		.program-pulje-time {
			font-weight: normal;
			font-size: var(--text-heading-4);
			color: var(--color-text-soft-50);
		}
	</style>
	<div class="surface-pane">
		<h2 class="surface-pane-title">
			Mitt festivalprogram
		</h2>
		if err != nil || interestErr != nil {
			<div style="padding: var(--spacing-4x); color: var(--color-error); background-color: var(--bg-error-light); border-radius: var(--border-radius-2x);">
				if err != nil {
					<p>Feil ved henting av arrangementer: { err.Error() }</p>
				}
				if interestErr != nil {
					<p>Feil ved henting av interesser: { interestErr.Error() }</p>
				}
			</div>
		} else if !userInfo.IsAdmin {
			<p style="font-style: italic;">kommer snart!</p>
		} else if userInfo.IsAdmin {
		<section class="program-pulje-list">
			for _, pulje := range puljer {
				<div class="program-pulje-container">
					<h3 class="program-pulje">
						{ pulje.displayName }
						<span class="program-pulje-time">{ pulje.time }</span>
					</h3>
					// Display priority: assigned event > interests > empty state
					if pulje.event.EventID != "" {
							{{ imageCardUrl := eventimage.GetEventImageUrl(pulje.event.EventID, "card", eventImageDir) }}
							@event_components.ProgramPuljeEvent(pulje.event.EventID, imageCardUrl, pulje.event.Title, pulje.event.Intro, pulje.event.EventType, pulje.event.IsGM)
						} else if len(pulje.interests) > 0 {
							{{ interestList := make([]event_components.Interest, len(pulje.interests)) }}
							{{
								for i, interest := range pulje.interests {
									interestList[i] = event_components.Interest{
										EventID:       interest.EventID,
										EventName:     interest.EventName,
										InterestLevel: interest.InterestLevel,
									}
								}
							}}
							@event_components.ProgramPuljeInterests(interestList)
						} else {
							@event_components.ProgramPuljeNoEvents()
						}
					</div>
				}
			</section>
		}
	</div>
}

type UserInterest struct {
	EventID       string
	EventName     string
	InterestLevel string
	PuljeID       string
}

func getAllInterestsForUser(userInfo requestctx.UserRequestInfo, db *sql.DB, logger *slog.Logger) ([]UserInterest, error) {
	logger.Info("Fetching interests for user", "userId", userInfo.Id)

	billettholdere, billettholderErr := billettholderService.GetBilettholdere(userInfo.Id, db, logger)
	if billettholderErr != nil {
		logger.Error("Failed to get billettholdere", "billettholderErr", billettholderErr)
		return nil, fmt.Errorf("unable to get billettholder: %w, id: %+v", billettholderErr, userInfo.Id)
	}

	if len(billettholdere) == 0 {
		logger.Info("User has no billettholdere")
		return []UserInterest{}, nil
	}

	billettholderID := billettholdere[0].ID

	query := `
		SELECT
			i.event_id,
			e.title,
			i.interest_level,
			i.pulje_id
		FROM interests i
		JOIN events e ON i.event_id = e.id
		WHERE i.billettholder_id = ?
		ORDER BY i.pulje_id ASC
	`

	rows, queryErr := db.Query(query, billettholderID)
	if queryErr != nil {
		logger.Error("Failed to query interests", "queryErr", queryErr)
		return nil, fmt.Errorf("unable to query interests: %w", queryErr)
	}
	defer rows.Close()

	interests := make([]UserInterest, 0)

	for rows.Next() {
		var interest UserInterest

		scanErr := rows.Scan(
			&interest.EventID,
			&interest.EventName,
			&interest.InterestLevel,
			&interest.PuljeID,
		)

		if scanErr != nil {
			logger.Error("Failed to scan interest", "scanErr", scanErr)
			continue
		}

		interests = append(interests, interest)
	}

	if rowsErr := rows.Err(); rowsErr != nil {
		logger.Error("Error iterating rows", "rowsErr", rowsErr)
		return nil, fmt.Errorf("error iterating interest rows: %w", rowsErr)
	}

	return interests, nil
}

	func GetAllEventsForUser(userInfo requestctx.UserRequestInfo, db *sql.DB, logger *slog.Logger) ([]UserEvent, error) {
		// Fetches all events for a user using UNION of two queries:
		// 1. Events the user is playing in (is_player = 1)
		// 2. Events the user is running as gamemaster (host)
		// A user can only be either a player OR a gamemaster for a specific event, never both	billettholdere, billettholderErr := billettholderService.GetBilettholdere(userInfo.Id, db, logger)
	if billettholderErr != nil {
		logger.Error("Failed to get billettholdere", "billettholderErr", billettholderErr)
		return nil, fmt.Errorf("unable to get billettholder: %w, id: %+v", billettholderErr, userInfo.Id)
	}

	if len(billettholdere) == 0 {
		return []UserEvent{}, nil
	}

	billettholderID := billettholdere[0].ID

		query := `
			// Query 1: Get events where user is a player
			SELECT
				ep.event_id,
				e.title,
				COALESCE(e.intro, '') as intro,
				COALESCE(e.description, '') as description,
				COALESCE(e.image_url, '') as image_url,
				COALESCE(e.host, 0) as host,
				e.event_type,
				ep.pulje_id,
				p.name as pulje_name,
				p.start_time,
				p.end_time,
				COALESCE(ep.is_gm, 0) as is_gm
			FROM events_players ep
			JOIN events e ON ep.event_id = e.id
			JOIN puljer p ON ep.pulje_id = p.id
			WHERE ep.billettholder_id = ?
				AND ep.is_player = 1

			UNION

			// Query 2: Get events where user is the gamemaster (host)
			SELECT
				ep.event_id,
				e.title,
				COALESCE(e.intro, '') as intro,
				COALESCE(e.description, '') as description,
				COALESCE(e.image_url, '') as image_url,
				COALESCE(e.host, 0) as host,
				e.event_type,
				ep.pulje_id,
				p.name as pulje_name,
				p.start_time,
				p.end_time,
				1 as is_gm
			FROM users u
			JOIN events e ON u.id = e.host
			JOIN event_puljer ep ON e.id = ep.event_id
			JOIN puljer p ON ep.pulje_id = p.id
			WHERE u.user_id = ?

			ORDER BY p.start_time ASC
		`	rows, queryErr := db.Query(query, billettholderID, userInfo.Id)
	if queryErr != nil {
		logger.Error("Failed to query events", "queryErr", queryErr)
		return nil, fmt.Errorf("unable to query events: %w", queryErr)
	}
	defer rows.Close()

	events := make([]UserEvent, 0)

	for rows.Next() {
		var event UserEvent

		scanErr := rows.Scan(
			&event.EventID,
			&event.Title,
			&event.Intro,
			&event.Description,
			&event.ImageURL,
			&event.Host,
			&event.EventType,
			&event.PuljeID,
			&event.PuljeName,
			&event.StartTime,
			&event.EndTime,
			&event.IsGM,
		)

		if scanErr != nil {
			logger.Error("Failed to scan event", "scanErr", scanErr)
			continue
		}
		events = append(events, event)
	}

	if rowsErr := rows.Err(); rowsErr != nil {
		logger.Error("Error iterating rows", "rowsErr", rowsErr)
		return nil, fmt.Errorf("error iterating event rows: %w", rowsErr)
	}

	return events, nil
}
