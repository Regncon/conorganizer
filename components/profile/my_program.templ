package profilecomponent

import (
	"database/sql"
	"fmt"
	"log/slog"
	"time"

	"github.com/Regncon/conorganizer/components/event_components"
	billettholderService "github.com/Regncon/conorganizer/service/billettholder"
	"github.com/Regncon/conorganizer/service/eventimage"
	"github.com/Regncon/conorganizer/service/requestctx"
)

type UserEvent struct {
	EventID     string
	Title       string
	Intro       string
	Description string
	ImageURL    string
	Host        string
	EventType   string
	PuljeID     string
	PuljeName   string
	StartTime   time.Time
	EndTime     time.Time
	IsGM        bool
}

templ MyPropgram(userInfo requestctx.UserRequestInfo, db *sql.DB, logger *slog.Logger, eventImageDir *string) {
	{{ events, err := GetAllEventsForUser(userInfo, db, logger) }}
	{{ interests, interestErr := getAllInterestsForUser(userInfo, db, logger) }}
	{{
		puljer := []struct {
			displayName string
			puljeID     string
			time        string
			event       UserEvent
			interests   []UserInterest
		}{
			{displayName: "Fredag kveld", puljeID: "FredagKveld", time: "(18:00 - 23:00)"},
			{displayName: "Lørdag morgen", puljeID: "LordagMorgen", time: "(10:00 - 15:00)"},
			{displayName: "Lørdag kveld", puljeID: "LordagKveld", time: "(18:00 - 23:00)"},
			{displayName: "Søndag morgen", puljeID: "SondagMorgen", time: "(10:00 - 15:00)"},
		}
	}}
	{{
		for i := range puljer {

			for _, event := range events {
				if event.PuljeName == puljer[i].displayName {
					puljer[i].event = event
					break
				}
			}

			for _, interest := range interests {
				if interest.PuljeID == puljer[i].puljeID {
					puljer[i].interests = append(puljer[i].interests, interest)
				}
			}
		}
	}}
	<style>
		.program-pulje-list {
			display: flex;
			flex-direction: column;
			gap: var(--responsive-pane-padding);
		}
		.program-pulje-container {
			display: flex;
			flex-direction: column;
			gap: var(--spacing-2x);
		}
		h3.program-pulje {
			font-size: var(--text-heading-3);
			font-weight: bold;
			color: var(--color-text-strong);
		}
		.program-pulje-time {
			font-weight: normal;
			font-size: var(--text-heading-4);
			color: var(--color-text-soft-50);
		}
	</style>
	<div class="surface-pane">
		<h2 class="surface-pane-title">
			Mitt festivalprogram
		</h2>
		if err != nil || interestErr != nil {
			<div style="padding: var(--spacing-4x); color: var(--color-error); background-color: var(--bg-error-light); border-radius: var(--border-radius-2x);">
				if err != nil {
					<p>Feil ved henting av arrangementer: { err.Error() }</p>
				}
				if interestErr != nil {
					<p>Feil ved henting av interesser: { interestErr.Error() }</p>
				}
			</div>
		} else {
			<section class="program-pulje-list">
				for _, pulje := range puljer {
					<div class="program-pulje-container">
						<h3 class="program-pulje">
							{ pulje.displayName }
							<span class="program-pulje-time">{ pulje.time }</span>
						</h3>
						if pulje.event.EventID != "" {
							{{ imageCardUrl := eventimage.GetEventImageUrl(pulje.event.EventID, "card", eventImageDir) }}
							{{ imageBannerUrl := eventimage.GetEventImageUrl(pulje.event.EventID, "banner", eventImageDir) }}
							@event_components.ProgramPuljeEvent(pulje.event.EventID, imageCardUrl, imageBannerUrl, pulje.event.Title, pulje.event.Intro, pulje.event.EventType, pulje.event.IsGM)
						} else if len(pulje.interests) > 0 {
							{{ interestList := make([]event_components.Interest, len(pulje.interests)) }}
							{{
								for i, interest := range pulje.interests {
									interestList[i] = event_components.Interest{
										EventID:       interest.EventID,
										EventName:     interest.EventName,
										InterestLevel: interest.InterestLevel,
									}
								}
							}}
							@event_components.ProgramPuljeInterests(interestList)
						} else {
							@event_components.ProgramPuljeNoEvents()
						}
					</div>
				}
			</section>
		}
	</div>
}

type UserInterest struct {
	EventID       string
	EventName     string
	InterestLevel string
	PuljeID       string
}

func getAllInterestsForUser(userInfo requestctx.UserRequestInfo, db *sql.DB, logger *slog.Logger) ([]UserInterest, error) {
	logger.Info("Fetching interests for user", "userId", userInfo.Id)

	billettholdere, billettholderErr := billettholderService.GetBilettholdere(userInfo.Id, db, logger)
	if billettholderErr != nil {
		logger.Error("Failed to get billettholdere", "billettholderErr", billettholderErr)
		return nil, fmt.Errorf("unable to get billettholder: %w, id: %+v", billettholderErr, userInfo.Id)
	}

	if len(billettholdere) == 0 {
		logger.Info("User has no billettholdere")
		return []UserInterest{}, nil
	}

	billettholderID := billettholdere[0].ID

	query := `
		SELECT
			i.event_id,
			e.title,
			i.interest_level,
			i.pulje_id
		FROM interests i
		JOIN events e ON i.event_id = e.id
		WHERE i.billettholder_id = ?
		ORDER BY i.pulje_id ASC,
			CASE i.interest_level
				WHEN 'Veldig interessert' THEN 1
				WHEN 'Middels interessert' THEN 2
				WHEN 'Litt interessert' THEN 3
				ELSE 999
			END ASC
	`

	rows, queryErr := db.Query(query, billettholderID)
	if queryErr != nil {
		logger.Error("Failed to query interests", "queryErr", queryErr)
		return nil, fmt.Errorf("unable to query interests: %w", queryErr)
	}
	defer rows.Close()

	interests := make([]UserInterest, 0)

	for rows.Next() {
		var interest UserInterest

		scanErr := rows.Scan(
			&interest.EventID,
			&interest.EventName,
			&interest.InterestLevel,
			&interest.PuljeID,
		)

		if scanErr != nil {
			logger.Error("Failed to scan interest", "scanErr", scanErr)
			continue
		}

		interests = append(interests, interest)
	}

	if rowsErr := rows.Err(); rowsErr != nil {
		logger.Error("Error iterating rows", "rowsErr", rowsErr)
		return nil, fmt.Errorf("error iterating interest rows: %w", rowsErr)
	}

	return interests, nil
}

func GetAllEventsForUser(userInfo requestctx.UserRequestInfo, db *sql.DB, logger *slog.Logger) ([]UserEvent, error) {
	billettholdere, billettholderErr := billettholderService.GetBilettholdere(userInfo.Id, db, logger)
	if billettholderErr != nil {
		logger.Error("Failed to get billettholdere", "billettholderErr", billettholderErr)
		return nil, fmt.Errorf("unable to get billettholder: %w, id: %+v", billettholderErr, userInfo.Id)
	}

	if len(billettholdere) == 0 {
		return []UserEvent{}, nil
	}

	billettholderID := billettholdere[0].ID

	query := `
		SELECT
			ep.event_id,
			e.title,
			COALESCE(e.intro, '') as intro,
			COALESCE(e.description, '') as description,
			COALESCE(e.image_url, '') as image_url,
			COALESCE(e.host, 0) as host,
			e.event_type,
			ep.pulje_id,
			p.name as pulje_name,
			p.start_time,
			p.end_time,
			ep.is_gm
		FROM events_players ep
		JOIN events e ON ep.event_id = e.id
		JOIN puljer p ON ep.pulje_id = p.id
		WHERE ep.billettholder_id = ?
			AND (ep.is_player = 1 OR ep.is_gm = 1)
		ORDER BY p.start_time ASC
	`

	rows, queryErr := db.Query(query, billettholderID)
	if queryErr != nil {
		logger.Error("Failed to query events", "queryErr", queryErr)
		return nil, fmt.Errorf("unable to query events: %w", queryErr)
	}
	defer rows.Close()

	events := make([]UserEvent, 0)

	for rows.Next() {
		var event UserEvent

		scanErr := rows.Scan(
			&event.EventID,
			&event.Title,
			&event.Intro,
			&event.Description,
			&event.ImageURL,
			&event.Host,
			&event.EventType,
			&event.PuljeID,
			&event.PuljeName,
			&event.StartTime,
			&event.EndTime,
			&event.IsGM,
		)

		if scanErr != nil {
			logger.Error("Failed to scan event", "scanErr", scanErr)
			continue
		}
		events = append(events, event)
	}

	if rowsErr := rows.Err(); rowsErr != nil {
		logger.Error("Error iterating rows", "rowsErr", rowsErr)
		return nil, fmt.Errorf("error iterating event rows: %w", rowsErr)
	}

	return events, nil
}
