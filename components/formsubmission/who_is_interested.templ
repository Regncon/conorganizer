package formsubmission

import (
	"database/sql"
	"log/slog"

	"encoding/json"
	"fmt"
	"github.com/Regncon/conorganizer/components/icons"
	"github.com/Regncon/conorganizer/components/ticket_holder"
	"github.com/Regncon/conorganizer/models"
)

type InterestWithHolder struct {
	BillettholderId int    `json:"billettholder_id"`
	EventId         string `json:"event_id"`
	PuljeId         string `json:"pulje_id"`
	InterestLevel   string `json:"interest_level"`
	FirstChoice     bool   `json:"first_choice"`
	IsGamemaster    bool   `json:"is_gm"`

	FirstName  string `json:"first_name"`
	LastName   string `json:"last_name"`
	TicketType string `json:"ticket_type"`
	IsOver18   bool   `json:"is_over_18"`
}

type AssignmentWithHolder = InterestWithHolder

// todo still some bugs with this query. I think there is some logic missing
var queryFirstChoice = `
                EXISTS (
                    SELECT
                        1
                    FROM
                        interests i2
                        JOIN events_players ep ON ep.billettholder_id = i2.billettholder_id
                        AND ep.event_id = i2.event_id
                        AND ep.pulje_id = i2.pulje_id
                    WHERE
                        i2.billettholder_id = i.billettholder_id
                        AND i2.pulje_id <> ''
                        AND i2.event_id <> i.event_id -- must be a different event
                        AND i2.interest_level = 'Veldig interessert'
                        AND (ep.is_player = 1 OR ep.is_gm = 1)
                    LIMIT
                        1
                ) AS first_choice
`

func GetInterestsForEvent(eventId string, db *sql.DB, logger *slog.Logger) ([]InterestWithHolder, error) {
	var query = `
            SELECT
                i.billettholder_id,
                i.event_id,
                i.pulje_id,
                i.interest_level,
                ` + queryFirstChoice + `,
                COALESCE(ep.is_gm, 0) AS is_gm,
                b.first_name,
                b.last_name,
                b.ticket_type,
                b.is_over_18
            FROM
                interests i
                JOIN billettholdere b ON b.id = i.billettholder_id
                LEFT JOIN events_players ep ON ep.billettholder_id = i.billettholder_id
                AND ep.event_id = i.event_id
                AND ep.pulje_id = i.pulje_id
            WHERE
                i.event_id = ?
                AND i.pulje_id <> ''
                AND COALESCE(ep.is_player, 0) = 0
                AND COALESCE(ep.is_gm, 0) = 0
            ORDER BY
                i.interest_level DESC
    `
	rows, queryErr := db.Query(query, eventId)
	if queryErr != nil {
		logger.Error("Failed to query interests with holders", "queryErr", queryErr)
		return nil, queryErr
	}

	defer rows.Close()
	var interests []InterestWithHolder
	for rows.Next() {
		var interest InterestWithHolder
		if scanErr := rows.Scan(
			&interest.BillettholderId,
			&interest.EventId,
			&interest.PuljeId,
			&interest.InterestLevel,
			&interest.FirstChoice,
			&interest.IsGamemaster,
			&interest.FirstName,
			&interest.LastName,
			&interest.TicketType,
			&interest.IsOver18,
		); scanErr != nil {
			logger.Error("Failed to scan interest with holder", "scanErr", scanErr)
			return nil, scanErr
		}
		interests = append(interests, interest)
	}

	if rowErr := rows.Err(); rowErr != nil {
		logger.Error("Row iteration error", "rowErr", rowErr)
		return nil, rowErr
	}
	return interests, nil
}

func GetAssigneesForEvent(eventId string, db *sql.DB, logger *slog.Logger) ([]InterestWithHolder, error) {
	var query = `
            SELECT
                ep.billettholder_id,
                ep.event_id,
                ep.pulje_id,
                -- this is because we can insert ppl from search without interest as gm
                COALESCE(i.interest_level, '') AS interest_level,
                ` + queryFirstChoice + `,
                COALESCE(ep.is_gm, 0) AS is_gm,
                b.first_name,
                b.last_name,
                b.ticket_type,
                b.is_over_18
            FROM
                events_players ep
                JOIN billettholdere b ON b.id = ep.billettholder_id
                LEFT JOIN interests i ON i.billettholder_id = ep.billettholder_id
                    AND i.event_id = ep.event_id
                    AND i.pulje_id = ep.pulje_id
            WHERE
                ep.event_id = ?
                AND (ep.is_player = 1 OR ep.is_gm = 1)
            ORDER BY
                ep.is_gm DESC,
                ep.inserted_time ASC
    `
	rows, queryErr := db.Query(query, eventId)
	if queryErr != nil {
		logger.Error("Failed to query assignments with holders", "queryErr", queryErr)
		return nil, queryErr
	}

	defer rows.Close()
	var assignments []AssignmentWithHolder
	for rows.Next() {
		var assignment AssignmentWithHolder
		if scanErr := rows.Scan(
			&assignment.BillettholderId,
			&assignment.EventId,
			&assignment.PuljeId,
			&assignment.InterestLevel,
			&assignment.FirstChoice,
			&assignment.IsGamemaster,
			&assignment.FirstName,
			&assignment.LastName,
			&assignment.TicketType,
			&assignment.IsOver18,
		); scanErr != nil {
			logger.Error("Failed to scan assignment with holder", "scanErr", scanErr)
			return nil, scanErr
		}
		assignments = append(assignments, assignment)
	}

	if rowErr := rows.Err(); rowErr != nil {
		logger.Error("Row iteration error", "rowErr", rowErr)
		return nil, rowErr
	}
	return assignments, nil
}

type Billettholder struct {
	Id        int
	FirstName string
	LastName  string
}

type ButtonInfo struct {
	Label  string
	Action string
}

func playerButtonAction(isAssigned bool, isGamemaster bool, assignAction string, removeAction string) ButtonInfo {
	if !isAssigned {
		return ButtonInfo{Label: "Tildel som spiller", Action: assignAction}
	}
	if isGamemaster {
		return ButtonInfo{Label: "Bytt til spiller", Action: assignAction}
	}
	return ButtonInfo{Label: "Fjern som spiller", Action: removeAction}
}

func gmButtonAction(isAssigned bool, isGamemaster bool, assignAction string, removeAction string) ButtonInfo {
	if !isAssigned {
		return ButtonInfo{Label: "Tildel som GM", Action: assignAction}
	}
	if isGamemaster {
		return ButtonInfo{Label: "Fjern som GM", Action: removeAction}
	}
	return ButtonInfo{Label: "Bytt til GM", Action: assignAction}
}

func getBillettholdere(db *sql.DB, logger *slog.Logger) ([]Billettholder, error) {
	var query = `
            Select id, first_name, last_name From billettholdere
    `
	rows, queryErr := db.Query(query)
	if queryErr != nil {
		logger.Error("Failed to query billettholdere", "queryErr", queryErr)
		return nil, queryErr
	}

	defer rows.Close()
	billettholdere := make([]Billettholder, 0)
	for rows.Next() {
		var billettholder Billettholder
		if scanErr := rows.Scan(
			&billettholder.Id,
			&billettholder.FirstName,
			&billettholder.LastName,
		); scanErr != nil {
			logger.Error("Failed to scan billettholder with holder", "scanErr", scanErr)
			return nil, scanErr
		}
		billettholdere = append(billettholdere, billettholder)
	}

	if rowErr := rows.Err(); rowErr != nil {
		logger.Error("Row iteration error", "rowErr", rowErr)
		return nil, rowErr
	}
	return billettholdere, nil
}

func UpdatePlayerStatus(eventId string,
	puljeId string,
	billettholderId int,
	isPlayer bool,
	isGM bool,
	db *sql.DB,
	logger *slog.Logger,
) error {
	query := `INSERT INTO
                        events_players (event_id, pulje_id, billettholder_id, is_player, is_gm, inserted_time)
                VALUES
                    (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
                ON CONFLICT(event_id, pulje_id, billettholder_id) DO UPDATE SET
                    is_player = EXCLUDED.is_player,
                    is_gm = EXCLUDED.is_gm,
                    inserted_time = CURRENT_TIMESTAMP
        `
	_, updatePlayerStatusErr := db.Exec(query, eventId, puljeId, billettholderId, isPlayer, isGM)
	if updatePlayerStatusErr != nil {
		logger.Error("Failed to update player status in the database", "updatePlayerStatusErr", updatePlayerStatusErr)
		return updatePlayerStatusErr
	}
	return nil
}

templ interestInPulje(eventId string, puljeId models.Pulje, interests []InterestWithHolder, isAssigned bool) {
	<style>

        .section {

            display: flex;
            gap: 1rem;
            place-content: space-between;
            flex-wrap: nowrap;
            margin-bottom: var(--spacing-1x);

            .start {
                display: flex;
                place-items: center;
                text-align: center;
                gap: 1ch;
                .is-gamemaster {
                    display: flex;
                    place-content: center;
                    place-items: center;
                    .is-gamemaster-icon {
                        color: var(--color-accent-cyan);
                    }
                }
                .first-choice {
                    color: var(--color-error);
                    font-weight: 700;
                }
            }
            .end {
                place-self: end;

                .btn--outline:hover {
                    color: var(--color-primary);
                    border-color: var(--color-primary);
                }
                .btn {
                    min-inline-size: 9.25rem;
                }

                .pickers {
                    place-self: center;
                    display: flex;
                    gap: var(--spacing-8x);

                        .button-size {
                            inline-size: fit-content;
                        }
                }
            }
        }
    </style>
	for _, interest := range interests {
		if interest.PuljeId == string(puljeId) {
			{{
				assignPlayerAction := fmt.Sprintf("$assignmentEventId = '%s'; $assignmentPuljeId = '%s'; $assignmentBillettholderId = %d; $assignmentIsPlayer = true; $assignmentIsGm = false; @put('/admin/approval/api/events_players/update_status')", eventId, puljeId, interest.BillettholderId)
				removePlayerAction := fmt.Sprintf("$assignmentEventId = '%s'; $assignmentPuljeId = '%s'; $assignmentBillettholderId = %d; $assignmentIsPlayer = false; $assignmentIsGm = false; @put('/admin/approval/api/events_players/update_status')", eventId, puljeId, interest.BillettholderId)
				assignGmAction := fmt.Sprintf("$assignmentEventId = '%s'; $assignmentPuljeId = '%s'; $assignmentBillettholderId = %d; $assignmentIsPlayer = false; $assignmentIsGm = true; @put('/admin/approval/api/events_players/update_status')", eventId, puljeId, interest.BillettholderId)
				removeGmAction := fmt.Sprintf("$assignmentEventId = '%s'; $assignmentPuljeId = '%s'; $assignmentBillettholderId = %d; $assignmentIsPlayer = false; $assignmentIsGm = false; @put('/admin/approval/api/events_players/update_status')", eventId, puljeId, interest.BillettholderId)
				playerAction := playerButtonAction(isAssigned, interest.IsGamemaster, assignPlayerAction, removePlayerAction)
				gmAction := gmButtonAction(isAssigned, interest.IsGamemaster, assignGmAction, removeGmAction)
				buttonsInfo := []ButtonInfo{playerAction, gmAction}
			}}
			<section
				class="item-card section"
			>
				<div class="start">
					if !isAssigned {
						<span>{ interest.InterestLevel }</span>
					}
					@ticketholder.NameInitials(interest.FirstName+" "+interest.LastName, string(interest.FirstName[0])+string(interest.LastName[0]))
					// todo: incomplete first choice logic
					if interest.FirstChoice {
						<p class="first-choice">Fått førstevalg</p>
					}
					if interest.IsGamemaster {
						<p class="is-gamemaster">
							<span class="is-gamemaster-icon" data-tippy-content={ fmt.Sprintf("%s %s er spilleder", interest.FirstName, interest.LastName) }>
								@icons.Icon(icons.Gamemaster, icons.Size24)
							</span>
							Spilleder
						</p>
					}
					<div style="display: flex; align-items: center; gap:0.5rem; ">
						if interest.IsOver18 {
							@icons.Icon(icons.EventAdultOnly, icons.Size24)
							<p><strong>Alder:</strong> Over 18</p>
						} else {
							@icons.Icon(icons.EventChildFriendly, icons.Size24)
							<p><strong>Alder:</strong> Under 18</p>
						}
					</div>
					<span>{ interest.TicketType }</span>
				</div>
				<div class="end">
					<div class="pickers">
						for _, buttonInfo := range buttonsInfo {
							<button
								class="btn btn--outline button-size"
								data-on:click={ buttonInfo.Action }
							>
								{ buttonInfo.Label }
							</button>
						}
					</div>
				</div>
			</section>
		}
	}
}

templ playersInPulje(eventId string, puljeId models.Pulje, interests []InterestWithHolder) {
	@interestInPulje(eventId, puljeId, interests, true)
}

templ gmSelectForm(eventId string, puljeId models.Pulje, billettholdere []Billettholder) {
	{{ billettholdereJson, _ := json.Marshal(billettholdere) }}
	<div class="gm-search-wrapper" style="margin-block-end: 2rem;">
		<form
			data-on:submit={ fmt.Sprintf("$assignmentPuljeId = '%s'; @post('/admin/approval/api/events_players/post/add_gm')", puljeId) }
		>
			<admin-gm-select
				data-billettholdere={ string(billettholdereJson) }
				data-on:gm-select="$assignmentBillettholderId = evt.detail.id"
				input-tippy="Søk etter billettholder"
			></admin-gm-select>
		</form>
		<script src="/static/web_components/admin_gm_select.js"></script>
	</div>
}

templ puljeSection(eventId string, title string, puljeId models.Pulje, interests []InterestWithHolder, assignees []InterestWithHolder, showGmForm bool, billettholdere []Billettholder) {
	<article
		class="form-card"
		data-style:display={ fmt.Sprintf("(!$isActive%s || !$isPublished%s) && 'none' || ''", puljeId, puljeId) }
	>
		<h2 style="margin-bottom:1rem;">{ title }</h2>
		<h2 style="margin-bottom:1rem;">Finn spilleder?</h2>
		@gmSelectForm(eventId, puljeId, billettholdere)
		<h2 style="margin-bottom:1rem;">Who is picked?</h2>
		@playersInPulje(eventId, puljeId, assignees)
		<h2 style="margin-bottom:1rem;">Who is interested?</h2>
		@interestInPulje(eventId, puljeId, interests, false)
	</article>
}

templ WhoIsInterested(eventId string, db *sql.DB, logger *slog.Logger) {
	{{ interests, err := GetInterestsForEvent(eventId, db, logger) }}
	{{ assignees, err := GetAssigneesForEvent(eventId, db, logger) }}
	{{ billettholdere, err := getBillettholdere(db, logger) }}
	<div
		style="
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-block: 2rem;
        "
		data-signals={ fmt.Sprintf("{assignmentEventId: '%s', assignmentBillettholderId: 0, assignmentPuljeId: '', assignmentIsPlayer: false, assignmentIsGm: false}", eventId) }
	>
		<article class="form-card">
			if err != nil {
				<p>Error fetching interests: { err.Error() }</p>
				return
			}
			<h2>Spillere</h2>
		</article>
		@puljeSection(eventId, "Fredag Kveld", models.PuljeFredagKveld, interests, assignees, true, billettholdere)
		@puljeSection(eventId, "Lørdag Morgen", models.PuljeLordagMorgen, interests, assignees, false, billettholdere)
		@puljeSection(eventId, "Lørdag Kveld", models.PuljeLordagKveld, interests, assignees, false, billettholdere)
		@puljeSection(eventId, "Søndag Morgen", models.PuljeSondagMorgen, interests, assignees, false, billettholdere)
	</div>
}
